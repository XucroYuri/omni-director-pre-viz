# Plan-Codex 整合增强方案（Codex Addendum，不与现有方案冲突）

**作者**：Codex  
**定位**：在不改变 `dev/Plan-Codex.md` 的核心红线与路线选择的前提下，提出一套“可以直接增强/补全/完善”的整合建议；同时给出**负面清单**（明确禁止的做法），并对“需方拍板项”给出**我的默认答案与理由**。  
**注意**：本文件是“可合入清单 + 默认决策建议”，不等价于强制变更；最终是否合入 `dev/Plan-Codex.md` / `rules.md` 仍应由需方确认。

---

## 0. 兼容性声明（确保不冲突）

本 Addendum **完全遵守并强化** `dev/Plan-Codex.md` 与 `rules.md` 的既定红线，不引入相反路线：

- **Local-first Desktop**：优先 Electron（Renderer/UI + Main/Local-Backend 分离），目标三端一键运行、绿色包、开源发布。
- **前端零密钥**：任何 Provider Key 均不进入 Renderer bundle/URL/本地持久化明文/日志。
- **Provider Source 唯一**：只允许 `aihubmix.com/gemini`（不再直连 Gemini 官方 API）。
- **视频模型唯一**：只允许 aihubmix 的 **Sora2**，并注释锁定。
- **生成主路径唯一**：1 次生成 1 张 **3x3 母图** → 物理切片 9 张 Angle；单 Angle 生成仅用于修正。
- **Beat-first**：`Script → Scene/Beat → Shot → Angle`，Beat 为主、Scene 为辅；允许手工合并/拆分。
- **Style Preset 双套**：Image/Video（Sora2）两套 Preset；Angle 文本保持 style-free，母图/视频顶层注入 Preset。

---

## 1. 我建议“直接补强”的关键点（可合入 Plan-Codex 的增强条目）

> 目标：把“容易翻车/容易被误实现”的环节做成**硬规范 + 可验证机制**，减少后续开发者走偏的概率。

### 1.1 P0：网格生成与切片鲁棒性（强烈建议列为必做）

**风险**：AI 生成的 3x3 网格可能出现边框不一致、格子略偏移、外框厚度不均，导致“物理切片”得到的 9 张子图存在边框残留/内容裁切错位，影响后续单 Angle 修正和交付对账。

**建议合入的硬策略**：

1) **母图 Prompt 必须包含“网格严格性约束”**  
   - 明确要求：严格 3x3、等分、边框线条一致、无额外装饰、无文字水印、无额外拼贴、画面内容必须落在各格内部等。
   - 该约束应由 Main/Local-Backend 统一拼接（Renderer 仅展示镜像提示）。

2) **切片算法支持“安全裁切 margin + 可选校准”**  
   - 默认：每格切片时内缩一个固定 margin（例如 1%~2%），降低“切到边框线/黑边”的概率。
   - 可选（推荐）：提供一次性的“网格校准 UI”（用户拖拽 2 条竖线+2 条横线或四角对齐）→ 保存为本 Episode 的 `gridCalibration` → 后续所有切片复用。

3) **可验证的切片自检**（不依赖 AI）  
   - 生成后对母图做快速检测：边框线是否可检测到 2 条竖分割 + 2 条横分割（即便是简单亮度投影峰值也可以）。  
   - 若自检失败：提示用户启用校准/或重新生成母图（并在任务记录里标注 `GRID_LAYOUT_INVALID`）。

**验收标准（建议写入 Plan-Codex 的验收）**：
- 95% 以上母图可“自动切片”得到无明显边框残留的 9 张子图（人工肉眼标准）。
- 自检失败时能引导用户“一次校准后复用”，并记录到 `manifest.json`/DB。

---

### 1.2 P0：Prompt Budgeter（长度预算 + 降噪 + Lint）

**风险**：9 槽 Angle 文字 + Ref Map + Asset Lock Prompt + Style Preset + JSON 包裹，极易超长，引发：
- Provider 端请求失败或截断（不可控）
- 成本上升（冗余 token）
- 生成结果偏离（prompt 噪声大）

**建议合入的硬策略**（Main/Local-Backend 权威执行）：

1) **预算单位优先用“字符数 + 结构规则”，而不是 token 精确计数**  
   - 理由：token 估算依赖模型分词器，离线本地实现成本与误差都较高；字符预算更稳定、更可控，且足以作为工程防线。

2) **Angle 文本强制 style-free + 去重**  
   - 对 9 槽：只允许“机位差异 + 内容差异”，禁止重复写“全局风格/同样的角色锁定句式”。
   - 自动去除重复短语（例如同一句“高质量、细节丰富”在 9 槽重复出现）。

3) **超限降噪策略（可解释、可回溯）**  
   - 先删“修饰词堆叠”，再删“重复镜头术语”，最后才压缩“中文画面描述”。  
   - 任何自动压缩必须产出 `budgetReport`：删了什么、为何删、删前/删后长度。

4) **Lint 规则（阻断式）**  
   - 若包含被禁止词（例如要求 9 张分别输出、要求输出文字水印、要求改变分隔线颜色等）→ `POLICY_VIOLATION`。  
   - 若 JSON schema 不合法/slot 缺失 → 阻断生成。

**验收标准**：
- 3x3 母图生成请求的“合成 JSON 提示词”在 P95 情况下不超预算（例如 8k 字符以内，具体阈值可配）。
- UI 能展示“预算告警”和“一键自动压缩”的结果差异（并可撤销）。

---

### 1.3 P0：Legacy 数据与行为的“可控迁移”（建议做，但不阻断 MVP）

**风险**：现有原型可能存在 LocalStorage/Base64/前端直连痕迹；若直接切到 Desktop 本地库，用户历史可能无法延续，且开发者可能“继续沿用坏习惯”。

**建议分两层处理（不和 Plan-Codex 冲突）**：

- **P0：迁移阻断（Hard Stop）**  
  - Desktop 版本启动时检测到旧版“危险存储结构”（例如 LocalStorage 中存在大体积图片/明文 key）→ 明确提示用户“升级后不再使用该方式”，并提供“导出旧数据（JSON/ZIP）”按钮（即便只是把旧数据打包留存，也比静默丢失强）。

- **P1：最佳努力迁移（Best-effort）**  
  - 把旧数据解析成新结构（SQLite 元数据 + 媒体落盘），失败则落到 `imports/legacy_dump.zip` 并记录迁移报告。

**验收标准**：
- 不会因为旧数据太大导致启动卡死（必须有体积阈值与分批处理）。
- 迁移成功/失败都有可追溯报告（`migration_report.json`）。

---

### 1.4 P1：网络与可用性（代理/重试/断点恢复的“工程化”）

本项不改变“离线边界”（离线不允许生成），但确保网络波动下更稳定：

- **系统代理/自定义代理**：提供 UI 配置（可选）并支持读取系统代理。
- **请求幂等与断点恢复**：任务表记录 request fingerprint（episodeId+shotId+gridId+params+promptHash）避免重复提交；重启后恢复队列。
- **可视化失败原因**：错误码映射到可执行建议（换分辨率/稍后重试/检查 key/检查代理）。

---

### 1.5 P1：UI 性能与信息架构（避免“做着做着又回到上帝组件”）

建议把以下约束写进计划/规则（不等于引入重型状态管理）：

- 长列表（Scenes/Beats/Shots/Gallery/Tasks）默认按虚拟列表实现（避免 Episode 长剧本时卡死）。
- “任务中心”与“图库”是独立路由/面板：避免把所有状态堆在一个组件里。
- Renderer 不保存大 Blob：只持有文件路径/缩略图引用，渲染时按需加载。

---

## 2. 负面清单（明确禁止采纳/禁止实现的做法）

> 目的：把“看似方便但一定会害死项目”的路径写死，减少后续团队误入歧途。

### 2.1 安全与开源红线（任何理由都不允许）
- 把任何 Provider Key 注入前端（`vite define process.env.*` / `import.meta.env` 进 bundle / localStorage 存 key / URL query 携带 key）。
- 在日志中打印 key、完整请求体（含 prompt/refs 的敏感信息）或把 key/敏感信息写入 `manifest.json`。
- 允许直连 Gemini 官方 API（无论“更快/更便宜/更稳定”），导致 Provider 分叉与开源安全风险。

### 2.2 模型与能力边界（避免路线漂移）
- 接入/调用除 **Sora2** 以外的视频模型（Veo 等），即使只做“实验入口”也不允许。
- 让 LLM/Agent 自动改模型 ID、自动切换模型、自动增加 Provider 兜底（必须人工锁定）。

### 2.3 业务主路径纠偏（避免成本爆炸与一致性崩坏）
- 对每个 Angle 分别调用绘图 API 生成 9 张图（除非用户点“单 Angle 修正”）。
- 把九宫格 Prompt 当成“9 个独立镜头”进行生成与资产绑定（Angle≠Shot）。
- 把 Style Preset 写进每个 Angle 文本（导致冗余与超长，且更易引发不一致）。

### 2.4 存储与性能（会直接把应用搞崩）
- 用 Base64/DataURL 长期保存 2K/4K 图片到内存/LocalStorage。
- 把大 Blob 放在 React state 中长期驻留（内存泄漏与重渲染灾难）。
- 依赖 CDN/importmap/在线字体作为生产必需（离线构建与开源发布会直接失败）。

### 2.5 过度设计（会拖慢交付且难以维护）
- 在 Desktop MVP 阶段引入 Redis/BullMQ/Postgres/OSS/S3/鉴权中心/NestJS 集群等云端组件（除非已明确转向云协作版本）。
- 为“未来插件化”提前做重型 Plugin System（先把单一主路径做对做稳）。
- 把 DB 拆到 “IP/Project/Season/Episode/Shot 各自一套 DB”（过度分裂会把迁移与备份复杂度指数放大）。

---

## 3. 需方拍板项：我的默认答案（含理由）

> 这些是我认为“现在就定死更省钱”的决策点；若需方不同意，仍可调整，但建议把替代方案与风险同时写入 `rules.md`。

### 3.1 网格切片鲁棒性是否 P0 必做？
**我的答案：是（P0 必做）**  
**理由**：
- 这是“单母图+物理切片”主路径的地基；一旦切片不稳定，所有后续（单 Angle 修正、命名对账、视频关联）都会连锁崩坏。
- 该增强不引入额外 Provider 成本，属于纯本地算法与 UX 的确定性收益。

### 3.2 Prompt Budgeter 是否 P0 必做？用什么单位管理？
**我的答案：是（P0 必做），以“字符数预算 + 结构化降噪”作为主单位**  
**理由**：
- token 精算会引入新的依赖与误差源；字符预算是工程上最稳的前置防线。
- Budgeter 能直接降低失败率与成本，且不会改变你们“中文为主”的 Prompt 策略。

### 3.3 是否必须做旧数据迁移？
**我的答案：P0 做“迁移阻断 + 导出旧数据”，P1 做“最佳努力迁移”，不阻断 MVP**  
**理由**：
- 完全不迁移会导致早期用户（或内部测试）历史断代，反馈噪声大；但“强做全迁移”可能拖慢第一期桌面化闭环。
- 先保证“旧数据可被用户保存/导出”，再在 P1 逐步做 best-effort 迁移，是性价比最高的折中。

### 3.4 IPC：`invoke + schema` 还是 `tRPC over IPC`？
**我的答案：P0 采用 `ipcRenderer.invoke + zod schema`，把 tRPC 作为 P2 可选**  
**理由**：
- `invoke+schema` 足够达到“类型安全 + 可维护 + 易调试”，且工程复杂度最低。
- tRPC over IPC 对多人协作很香，但会增加样板与调试成本；等主路径跑通再上更稳。

### 3.5 Key 存储：keytar（系统 Keychain）还是 electron-store（加密落盘）？
**我的答案：P0 用 `electron-store` 加密落盘（可选用户密码/OS 派生密钥），P1 再评估引入 keytar**  
**理由**：
- keytar 是原生依赖：跨平台打包/CI 构建更容易踩坑，影响“一键运行/开源构建成功率”。
- electron-store 方案更轻、更可控；在“单机本地工具”语境下足够好用。若后续有更高安全等级需求，再引入 keytar。

### 3.6 是否把“系统代理/自定义代理”列为 P1 必做？
**我的答案：是（P1 必做）**  
**理由**：
- 本项目 100% 依赖外部生成 API（图片/视频），网络连通性就是可用性；代理支持是提升成功率的低成本手段。
- 不改变任何安全红线（仍是 Main 发起请求、Key 不出前端）。

### 3.7 DB 拆分策略（Season 一个 DB vs Episode 独立 DB）
**我的答案：采用 Plan-Codex 的“两级 DB”作为默认（`season.db` + `episode.db`），不再往更细拆**  
**理由**：
- 兼顾资产复用（Season）与单集可移植/可备份（Episode）。
- 进一步细拆（每层一个 DB）收益不成比例，迁移/导出/一致性校验会变复杂。

---

## 4. 建议的“合入方式”（避免把 Plan-Codex 越写越大）

若需方同意合入本 Addendum 的内容，我建议合入策略是：

- `dev/Plan-Codex.md`：只合入“会影响实现路径与验收标准”的硬条款（网格鲁棒性、Budgeter、迁移策略、代理支持、默认决策）。
- `rules.md`：只合入“禁止事项 + 锁定事项 + 工作习惯”，让规则可执行、可审查。
- 其余细节（算法伪代码、迁移脚本细节、UI 校准交互稿）留在 `dev/` 的模块文档中，避免主计划膨胀。

---

## 5. 建议新增的后续子文档（可选，便于分工）

> 这些不是强制，但能让多人协作更顺滑（按模块拆文档，避免一个文件变巨石）。

- `dev/Spec-GridCut-Calibrator.md`：网格自检/校准/切片 margin 的算法与 UI 规范。
- `dev/Spec-PromptBudgeter.md`：预算阈值、降噪策略、Lint 规则、budgetReport schema。
- `dev/Spec-LegacyMigration.md`：旧数据识别、导出格式、best-effort 迁移策略与回滚。
- `dev/Spec-Proxy-Network.md`：代理配置、错误码映射、重试与断点恢复策略。

---

**最后更新**：2025-12-20  
**状态**：待需方确认“合入范围与优先级”

